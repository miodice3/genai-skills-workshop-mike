# -*- coding: utf-8 -*-
"""lab5

Automatically generated by Colab.

Original file is located at
    https://colab.research.google.com/embedded/projects/qwiklabs-gcp-01-c75658565206/locations/us-central1/repositories/bcf69584-b7a9-48d0-93d8-03d19c742abb
"""

pip install --upgrade google-genai requests googlemaps

GOOGLE_API_KEY = "AIzaSyDR3ZS-yZTpO8CkVd1YMLbKzGPm8MGTy8w"

# ⚠️ Replace with your city and state
CITY = "Denver"
STATE = "CO"

# NOAA requires a User-Agent header. Use an email or project name.
# It helps them contact you if there's an issue.
NOAA_USER_AGENT = "MyWeatherApp/1.0 (mike@gameplan.tech)"


import googlemaps
import requests

def get_lat_long_from_city(city: str, state: str) -> tuple[float, float] | None:
    """Uses Google Geocoding API to get latitude and longitude."""
    try:
        gmaps = googlemaps.Client(key=GOOGLE_API_KEY)

        # Combine city and state into a single address string
        address = f"{city}, {state}, USA"

        # Geocode the address
        geocode_result = gmaps.geocode(address)

        if geocode_result:
            location = geocode_result[0]['geometry']['location']
            latitude = location['lat']
            longitude = location['lng']
            # print(f"✅ Geocoding successful: {city}, {state} is at Lat: {latitude}, Long: {longitude}")
            return latitude, longitude
        else:
            print(f"❌ Geocoding failed: Could not find coordinates for {city}, {state}.")
            return None
    except Exception as e:
        print(f"❌ An error occurred during geocoding: {e}")
        return None

# --- Execution for Geocoding ---
coordinates = get_lat_long_from_city(CITY, STATE)

def get_grid_points(latitude: float, longitude: float, user_agent: str) -> tuple[str, int, int] | None:
    """Uses NOAA /points endpoint to get WFO and grid points."""
    try:
        # round to avoid handling redirect from API w less precision
        #
        points_url = f"https://api.weather.gov/points/{latitude:.4f},{longitude:.4f}"
        headers = {'User-Agent': user_agent}

        response = requests.get(points_url, headers=headers)
        response.raise_for_status() # Raises an HTTPError for bad responses (4xx or 5xx)

        data = response.json()
        properties = data['properties']

        wfo = properties['cwa']
        grid_x = properties['gridX']
        grid_y = properties['gridY']

        # print(f"✅ Grid points successful: WFO: {wfo}, GridX: {grid_x}, GridY: {grid_y}")
        return wfo, grid_x, grid_y

    except requests.exceptions.HTTPError as err:
        print(f"❌ NOAA API failed (HTTP Error): {err}")
        return None
    except Exception as e:
        print(f"❌ An error occurred getting grid points: {e}")
        return None

# --- Execution for Grid Points ---
if coordinates:
    lat, lon = coordinates
    grid_data = get_grid_points(lat, lon, NOAA_USER_AGENT)
else:
    grid_data = None

def get_todays_forecast(wfo: str, grid_x: int, grid_y: int, user_agent: str):
    """Uses NOAA /gridpoints endpoint to get the daily forecast and prints 'Today's' forecast."""
    if not wfo or not grid_x or not grid_y:
        print("❌ Cannot fetch forecast without valid grid data.")
        return

    try:
        # Construct the final forecast URL
        forecast_url = f"https://api.weather.gov/gridpoints/{wfo}/{grid_x},{grid_y}/forecast"
        headers = {'User-Agent': user_agent}

        response = requests.get(forecast_url, headers=headers)
        response.raise_for_status()

        data = response.json()
        periods = data['properties']['periods']

        if periods:
            # The first period is usually 'Today' or the current period
            today_forecast = periods[0]

            # print("\n--- ☀️ Today's Forecast ---")
            # print(f"**Period:** {today_forecast['name']}")
            # print(f"**Temperature:** {today_forecast['temperature']}°{today_forecast['temperatureUnit']}")
            # print(f"**Wind:** {today_forecast['windSpeed']} from {today_forecast['windDirection']}")
            # print(f"**Details:** {today_forecast['detailedForecast']}")
            forecast = "\n--- ☀️ Today's Forecast ---"
            forecast += f"**Period:** {today_forecast['name']}"
            forecast += f"**Temperature:** {today_forecast['temperature']}°{today_forecast['temperatureUnit']}"
            forecast += f"**Wind:** {today_forecast['windSpeed']} from {today_forecast['windDirection']}"
            forecast += f"**Details:** {today_forecast['detailedForecast']}"
            return forecast
        else:
            print("❌ Forecast data is empty.")

    except requests.exceptions.HTTPError as err:
        print(f"❌ NOAA API failed (HTTP Error): {err}")
    except Exception as e:
        print(f"❌ An error occurred getting the forecast: {e}")

# --- Final Execution for Forecast ---
if grid_data:
    wfo, grid_x, grid_y = grid_data
    get_todays_forecast(wfo, grid_x, grid_y, NOAA_USER_AGENT)

def get_weather_from_city_state(city: str, state: str):
  """
  Retrieves and prints the current weather forecast for a given city and state.

  This function first converts the city and state names into geographic
  coordinates (latitude and longitude). It then uses these coordinates
  to determine the National Weather Service (NWS) forecast office (WFO)
  and grid points. Finally, it fetches and prints today's forecast.

  Args:
      city (str): The name of the city (e.g., "Denver").
      state (str): The two-letter state abbreviation (e.g., "CO").

  Returns:
      None: The function prints the forecast directly and does not
            return a value.
  """
  latitude, longitude = get_lat_long_from_city(city, state)
  wfo, grid_x, grid_y = get_grid_points(latitude, longitude, NOAA_USER_AGENT)
  print(get_todays_forecast(wfo, grid_x, grid_y, NOAA_USER_AGENT))

# test functionality
get_weather_from_city_state("Denver", "CO")

# export GOOGLE_CLOUD_API_KEY="YOUR_API_KEY"


from google import genai
from google.genai import types
import base64
import os

def generate():
  client = genai.Client(
      vertexai=True,
      # api_key=os.environ.get("GOOGLE_CLOUD_API_KEY"),
  )

  model = "gemini-3-pro-preview"
  # This is the new, clean contents list
  contents = [
    types.Content(
      role="user",
      parts=[
        types.Part.from_text(text="""What is the weather forecast for Los Angeles, CA?""")
      ]
    ),
  ]

# 1. Define the tool schema for the function
  weather_tool = types.Tool(
      function_declarations=[
          types.FunctionDeclaration(
              name="get_weather_from_city_state",
              description=get_weather_from_city_state.__doc__.strip(),
              parameters=types.Schema(
                  type=types.Type.OBJECT,
                  properties={
                      "city": types.Schema(type=types.Type.STRING, description="The name of the city, e.g., 'Denver'."),
                      "state": types.Schema(type=types.Type.STRING, description="The two-letter abbreviation for the state, e.g., 'CO'."),
                  },
                  required=["city", "state"],
              ),
          )
      ]
  )

  # 2. Define the Retrieval configuration as a Tool object
  retrieval_tool = types.Tool(
      retrieval=types.Retrieval(
          vertex_rag_store=types.VertexRagStore(
              rag_resources=[
                  types.VertexRagStoreRagResource(
                      rag_corpus="projects/720196750972/locations/us-east1/ragCorpora/4749045807062188032"
                  )
              ],
          )
      )
  )

  tools = [
    retrieval_tool,
    weather_tool
  ]

  generate_content_config = types.GenerateContentConfig(
    temperature = 1,
    top_p = 0.95,
    max_output_tokens = 65535,
    safety_settings = [types.SafetySetting(
      category="HARM_CATEGORY_HATE_SPEECH",
      threshold="OFF"
    ),types.SafetySetting(
      category="HARM_CATEGORY_DANGEROUS_CONTENT",
      threshold="OFF"
    ),types.SafetySetting(
      category="HARM_CATEGORY_SEXUALLY_EXPLICIT",
      threshold="OFF"
    ),types.SafetySetting(
      category="HARM_CATEGORY_HARASSMENT",
      threshold="OFF"
    )],
    tools = tools,
    # retrieval = retrieval_config,
    thinking_config=types.ThinkingConfig(
      thinking_level="HIGH",
    ),
  )

  for chunk in client.models.generate_content_stream(
    model = model,
    contents = contents,
    config = generate_content_config,
    ):
    if not chunk.candidates or not chunk.candidates[0].content or not chunk.candidates[0].content.parts:
        continue
    print(chunk.text, end="")

generate()

# backend API functionality