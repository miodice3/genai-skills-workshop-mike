# -*- coding: utf-8 -*-
"""student-01-d0ec89363b76 (Dec 4, 2025, 10:23:48 AM)

Automatically generated by Colab.

Original file is located at
    https://colab.research.google.com/embedded/projects/qwiklabs-gcp-04-69ab7976b631/locations/us-central1/repositories/aa967f34-2501-4572-9b70-03755e9ef962
"""

# @title
pip install --upgrade google-genai requests googlemaps

# @title
GOOGLE_API_KEY = "AIzaSyA6cVm8Fld4Mov2ZDDK-ydKFVvtKKZQ4HM"
# KEY = "AIzaSyA6cVm8Fld4Mov2ZDDK-ydKFVvtKKZQ4HM"

CITY = "Denver"
STATE = "CO"

# NOAA requires a User-Agent header. Use an email or project name.
# It helps them contact you if there's an issue.
NOAA_USER_AGENT = "MyWeatherApp/1.0 (mike@gameplan.tech)"


import googlemaps
import requests

# @title
import googlemaps
import requests

# Ideally, retrieve this from a secure store like colab user_secrets
# from google.colab import userdata
# GOOGLE_API_KEY = userdata.get('my_maps_key')

def get_lat_long_from_city(city: str, state: str) -> tuple[float, float] | None:
    try:
        gmaps = googlemaps.Client(key=GOOGLE_API_KEY)
        address = f"{city}, {state}, USA"

        # Geocode the address
        geocode_result = gmaps.geocode(address)

        if geocode_result:
            location = geocode_result[0]['geometry']['location']
            return location['lat'], location['lng']
        else:
            print(f"❌ Geocoding returned 0 results for {city}, {state}.")
            return None

    except googlemaps.exceptions.ApiError as e:
        # This specific exception often contains the detailed 'status' and 'error_message'
        print(f"❌ Google Maps API Error: {e}")
        print(f"   Status: {e.status}")
        print(f"   Message: {e.message}")
        return None
    except Exception as e:
        print(f"❌ General Error: {e}")
        return None

# Execution
coordinates = get_lat_long_from_city("Denver", "CO")
if coordinates:
    print(f"✅ Coordinates: {coordinates}")

# @title
def get_grid_points(latitude: float, longitude: float, user_agent: str) -> tuple[str, int, int] | None:
    """Uses NOAA /points endpoint to get WFO and grid points."""
    try:
        # round to avoid handling redirect from API w less precision
        #
        points_url = f"https://api.weather.gov/points/{latitude:.4f},{longitude:.4f}"
        headers = {'User-Agent': user_agent}

        response = requests.get(points_url, headers=headers)
        response.raise_for_status() # Raises an HTTPError for bad responses (4xx or 5xx)

        data = response.json()
        properties = data['properties']

        wfo = properties['cwa']
        grid_x = properties['gridX']
        grid_y = properties['gridY']

        # print(f"✅ Grid points successful: WFO: {wfo}, GridX: {grid_x}, GridY: {grid_y}")
        return wfo, grid_x, grid_y

    except requests.exceptions.HTTPError as err:
        print(f"❌ NOAA API failed (HTTP Error): {err}")
        return None
    except Exception as e:
        print(f"❌ An error occurred getting grid points: {e}")
        return None

# --- Execution for Grid Points ---
if coordinates:
    lat, lon = coordinates
    grid_data = get_grid_points(lat, lon, NOAA_USER_AGENT)
    print(grid_data)
else:
    grid_data = None
    print("no grid data")

# @title
def get_todays_forecast(wfo: str, grid_x: int, grid_y: int, user_agent: str):
    """Uses NOAA /gridpoints endpoint to get the daily forecast and prints 'Today's' forecast."""
    if not wfo or not grid_x or not grid_y:
        print("❌ Cannot fetch forecast without valid grid data.")
        return

    try:
        # Construct the final forecast URL
        forecast_url = f"https://api.weather.gov/gridpoints/{wfo}/{grid_x},{grid_y}/forecast"
        headers = {'User-Agent': user_agent}

        response = requests.get(forecast_url, headers=headers)
        response.raise_for_status()

        data = response.json()
        periods = data['properties']['periods']

        if periods:
            # The first period is usually 'Today' or the current period
            today_forecast = periods[0]

            # print("\n--- ☀️ Today's Forecast ---")
            # print(f"**Period:** {today_forecast['name']}")
            # print(f"**Temperature:** {today_forecast['temperature']}°{today_forecast['temperatureUnit']}")
            # print(f"**Wind:** {today_forecast['windSpeed']} from {today_forecast['windDirection']}")
            # print(f"**Details:** {today_forecast['detailedForecast']}")
            forecast = "\n--- ☀️ Today's Forecast ---"
            forecast += f"**Period:** {today_forecast['name']}"
            forecast += f"**Temperature:** {today_forecast['temperature']}°{today_forecast['temperatureUnit']}"
            forecast += f"**Wind:** {today_forecast['windSpeed']} from {today_forecast['windDirection']}"
            forecast += f"**Details:** {today_forecast['detailedForecast']}"
            return forecast
        else:
            print("❌ Forecast data is empty.")
            return None

    except requests.exceptions.HTTPError as err:
        print(f"❌ NOAA API failed (HTTP Error): {err}")
        return None
    except Exception as e:
        print(f"❌ An error occurred getting the forecast: {e}")
        return None

# @title
def get_weather_from_city_state(city: str, state: str):
  """
  Retrieves and prints the current weather forecast for a given city and state.

  This function first converts the city and state names into geographic
  coordinates (latitude and longitude). It then uses these coordinates
  to determine the National Weather Service (NWS) forecast office (WFO)
  and grid points. Finally, it fetches and prints today's forecast.

  Args:
      city (str): The name of the city (e.g., "Denver").
      state (str): The two-letter state abbreviation (e.g., "CO").

  Returns:
      None: The function prints the forecast directly and does not
            return a value.
  """
  latitude, longitude = get_lat_long_from_city(city, state)
  wfo, grid_x, grid_y = get_grid_points(latitude, longitude, NOAA_USER_AGENT)
  string_forecast = get_todays_forecast(wfo, grid_x, grid_y, NOAA_USER_AGENT)
  print('logging from get_weather_from_city_state ')
  print(string_forecast)
  return string_forecast

# test functionality
get_weather_from_city_state("Denver", "CO")

import logging
from google import genai
from google.genai import types
import os

# --- Recursive Response Handler (ROBUST FIX) ---
def handle_response(client: genai.Client, response: types.GenerateContentResponse, contents: list, config: types.GenerateContentConfig, model: str):

    # 1. Check for function calls
    function_call_part = None
    # We iterate to find the specific part containing the function call
    if response.candidates and response.candidates[0].content and response.candidates[0].content.parts:
        for part in response.candidates[0].content.parts:
            if part.function_call:
                function_call_part = part
                break

    if function_call_part:
        function_obj = function_call_part.function_call

        # --- CRITICAL: Capture the Call ID ---
        # The API requires this ID to match the response later.
        # If it's None, we default to an empty string or handle gracefully,
        # but for Gemini 1.5 it should always be present.
        call_id = getattr(function_obj, 'id', None)

        print(f"Model requested: {function_obj.name}")
        print(f"Call ID detected: {call_id}") # Debug print to verify ID exists

        result_part = None

        if function_obj.name == "get_weather_from_city_state":
            try:
                # Extract args
                args = function_obj.args
                city = args.get("city")
                state = args.get("state")

                # Execute your local function
                result_output = get_weather_from_city_state(city, state)
                print(f"Tool execution result: {str(result_output)[:50]}...")

                # --- FIX 1: Construct the Tool Response Manually ---
                # We build the object explicitly to ensure the ID is set correctly.
                result_part = types.Part(
                    function_response=types.FunctionResponse(
                        name="get_weather_from_city_state",
                        response={"content": result_output}, # Must be a dict
                        id=call_id # PASS THE ID BACK
                    )
                )
            except Exception as e:
                logger.error(f"Error executing weather tool: {e}")

        if not result_part:
            logger.error("No result generated from tool execution.")
            return

        # --- FIX 2: Sanitize the Model's Turn in History ---
        # Instead of reusing the raw 'function_call_part' from the API response (which can have hidden metadata),
        # we reconstruct a clean FunctionCall object for the history. This prevents 400 errors.
        clean_function_call = types.FunctionCall(
            name=function_obj.name,
            args=function_obj.args,
            id=call_id
        )

        sanitized_model_turn = types.Content(
            role="model",
            parts=[types.Part(function_call=clean_function_call)]
        )
        contents.append(sanitized_model_turn)

        # Append the Tool Response (role="tool")
        tool_turn = types.Content(
            role="tool",
            parts=[result_part]
        )
        contents.append(tool_turn)

        logger.info("Recursively calling model with updated history...")

        # 4. Recursive Call
        try:
            next_response = client.models.generate_content(
                model=model,
                contents=contents,
                config=config,
            )
            handle_response(client, next_response, contents, config, model)
        except Exception as e:
            logger.error(f"API Error during recursion: {e}")
            # print(contents) # Uncomment to inspect history if it fails again

    else:
        # Base case: Text response
        logger.info("Final response received.")
        print("\n--- Final Answer ---")
        if response.text:
            print(response.text)

# Set up logging
logging.basicConfig(level=logging.INFO)
logger = logging.getLogger(__name__)

# --- Main Generation Function ---
def generate():
  # 1. Initialize Client
  logger.info("Initializing Gemini Client...")
  # NOTE: Replace 'vertexai=True' with 'api_key=os.environ.get("GEMINI_API_KEY")'
  # if you are using the public API key approach.
  # client = genai.Client(vertexai=True)
  client = genai.Client(api_key=GOOGLE_API_KEY)
  logger.info("Client initialized.")

  model = "gemini-2.5-pro"

  # 2. Define Contents (Mutable list for history)
  contents = [
    types.Content(
      role="user",
      parts=[
        types.Part.from_text(text="""What is the weather forecast for Los Angeles, CA? use the x_weather_tool""")
        # types.Part.from_text(text="""Can you tell me about the Alaska Department of Snow? what are some facts about it""")
      ]
    ),
  ]

  # 3. Define Function Calling Tool (Weather)
  logger.info("Defining Function Calling Tool (Weather)...")
  weather_tool_declaration = types.FunctionDeclaration(
    name="get_weather_from_city_state",
    description=get_weather_from_city_state.__doc__.strip(),
    parameters=types.Schema(
        type=types.Type.OBJECT,
        properties={
            "city": types.Schema(type=types.Type.STRING, description="The name of the city, e.g., 'Denver'."),
            "state": types.Schema(type=types.Type.STRING, description="The two-letter abbreviation for the state, e.g., 'CO'."),
        },
        required=["city", "state"],
    ),
  )

  # Tool object for function calling
  x_weather_tool = types.Tool(
    function_declarations=[
        weather_tool_declaration
    ]
  )
  logger.info("Function Calling Tool defined.")

  # # 4. Define Retrieval Tool (RAG)
  # logger.info("Defining Retrieval Tool (RAG)...")
  # retrieval_tool = types.Tool(
  #     retrieval=types.Retrieval(
  #         vertex_rag_store=types.VertexRagStore(
  #             rag_resources=[
  #                 types.VertexRagStoreRagResource(
  #                     rag_corpus="projects/720196750972/locations/us-east1/ragCorpora/4749045807062188032"
  #                 )
  #             ],
  #         )
  #     )
  # )
  # logger.info("Retrieval Tool defined.")

  # 5. Define GenerateContentConfig
  logger.info("Defining GenerateContentConfig with combined tools list...")
  # all_tools = [retrieval_tool, x_weather_tool]
  all_tools = [x_weather_tool]

  generate_content_config = types.GenerateContentConfig(
    temperature = 1,
    top_p = 0.95,
    max_output_tokens = 65535,
    safety_settings = [types.SafetySetting(
      category="HARM_CATEGORY_HATE_SPEECH", threshold="OFF"
    ),types.SafetySetting(
      category="HARM_CATEGORY_DANGEROUS_CONTENT", threshold="OFF"
    ),types.SafetySetting(
      category="HARM_CATEGORY_SEXUALLY_EXPLICIT", threshold="OFF"
    ),types.SafetySetting(
      category="HARM_CATEGORY_HARASSMENT", threshold="OFF"
    )],

    tools = all_tools,

    # thinking_config=types.ThinkingConfig(
    #   thinking_level="HIGH",
    # ),
  )
  logger.info("GenerateContentConfig defined.")

  # 6. Call generate_content (initial call)
  logger.info("Calling client.models.generate_content (Initial Call)...")

  # try:
  initial_response = client.models.generate_content(
    model = model,
    contents = contents,
    config = generate_content_config,
  )
  logger.info("Initial response received.")

  # 7. Start the recursive handling process
  handle_response(client, initial_response, contents, generate_content_config, model)

  # except Exception as e:
  #   logger.error(f"An error occurred during content generation: {e}")

if __name__ == "__main__":
    generate()